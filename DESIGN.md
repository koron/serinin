# Design of serinin

## What is serinin

serinin は受けたリクエストをバックエンドの複数のエンドポイントに転送する一種の
リバースプロキシで、それらエンドポイントが返すレスポンスのマルチプレクサとして
機能します。

serinin はリクエスト毎にリクエストIDを発行します。serinin はエンドポイントから
のレスポンスを redis や memcached 等のストアに非同期に取得し格納します。また指
定時間(初期値:200ms)以内に返らなかったエンドポイントのレスポンスは格納しませ
ん。また格納したレスポンスは一定時間(`"expire_in"`)で消えるように設定します。

serinin自身のレスポンスにはリクエストIDと各エンドポイントの名前が格納されます。

クライアントは任意の時間経過後に、リクエストID(およびエンドポイント名)を用いて
各ストアに所定の方法でレスポンスの本文を問い合わせます。
エンドポイント名はserininのレスポンス

各レスポンスの長さに制限はありませんが数十バイトから長くとも数Kバイトを想定いま
す。

## How to access responses

クライアントがレスポンスにアクセスする方法はストア毎に異なります。

### Redis store

redis ストアにおいてはレスポンスはリクエストIDをキーにしてハッシュとして格納さ
れます。

ハッシュ内のフィールド名と意味は以下の通りです。

* `_id` - リクエストID
* `_method` - リクエストメソッド
* `_url` - リクエストURL(パス)
* `{エンドポイント名}` - 各エンドポイントが返したレスポンス本文

クライアントがアクセスする際は
[`HGETALL {リクエストID}`](https://redis.io/commands/hgetall)
コマンドを用いる想定です。

### Memcache store

memcache ストアにおいてはレスポンスはリクエストIDおよびエンドポイント名をキーに
して格納されます。

キーの定義と対応する値の意味は以下の通りです。

* `{リエクエストID}` - リクエストの情報が JSON Object で格納される:

    * `_id` - リクエストID
    * `_method` - リクエストメソッド
    * `_url` - リクエストURL(パス)

* `{リクエストID}.{エンドポイント名}` - 各エンドポイントが返したレスポンス本文

## How to work serinin

serinin はクライアントからリクエストを受けると以下のように動作します。このリク
エストはリソースが許す限り並列に処理しますが、数が多くなると輻輳を起こしパ
フォーマンスが低下するため `-handler {同時リクエスト処理数}` オプションで制限
することを推奨します。

1. リクエストIDを生成する (UUIDv4)
2. ストアにリクエストIDを含むリクエストの情報を保存する 
3. ジョブキューにエンドポイント毎の取得&格納ジョブを投入する
4. リクエストIDおよびエンドポイント名を含むレスポンスをクライアントに返す

    レスポンスはJSON Objectで以下のプロパティを持つ

    * `request_id` - 文字列。リクエストID
    * `endpoints` - 文字列の配列。全てのエンドポイント名

ジョブキューは標準ではリソースの許す限り並列に処理を試みますが、こちらも数が多
くなると輻輳を起こしパフォーマンスが低下するため `-worker {同時実行ジョブ数}`
オプションで制限することを推奨します。「同時実行ジョブ数」の参考値は「同時リク
エスト処理数」×「エンドポイント数」です。

取得&格納ジョブはエンドポイントにリクエストを転送し、そのレスポンスをストアに格
納します。転送するリクエストには元リクエストのクエリー文字列が適用されます。指
定時間内にエンドポイントからレスポンスが得られない場合はストアには何も記録しま
せん。また仮にがレスポンスが得られてもストアでの記録中に指定時間を超過した場合
には記録されないことがあります。

### Why not?

Goはgoroutineにより気軽に並列処理が可能ですが、コンピューターで利用可能なCPUコ
ア数を大きく超えるgoroutineを起動すると極端にパフォーマンスが悪くなる他、最悪リ
ソース(スレッド数やメモリ等)不足でpanicにより終了してしまいます。それを避け安定
した動作をし続けるためにはhttp.Serverで同時に処理するリクエスト数を制限するなど
して、goroutineの数を制限するもしくは厳密に管理する必要があります。

また特別なケースを除きgoroutineの実行時間を可能な限り短く保つことも重要です。リ
クエストが定常的に発生する状況下で1つのgoroutineの実行時間が長くなってしまう
と、同時に起動されるgoroutine数が多くなり結果として不必要なパフォーマンスの低下
を招くことになります。
